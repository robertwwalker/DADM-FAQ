{
  "hash": "67e979fcfc478e80108cb4296ec79035",
  "result": {
    "markdown": "---\ntitle: Tables, Pivots, Bars, and Mosaics\nauthor: Robert W. Walker\ndate: '2019-10-09'\nslug: tables-pivots-bars-and-mosaics\ncategories:\n  - R\n  - tidyverse\n  - tables\ntags:\n  - tidyverse\n  - R Markdown\nimage: thumbnail.jpg\n---\n\n\n\n\n# R Markdown\n\nThere is detailed help for all that Markdown can do under Help in the RStudio.  The key to it is knitting documents with the *Knit* button in the RStudio.  If we use helpers like the R Commander, Radiant, or \n*esquisse*, we will need the R code implanted in the Markdown document in particular ways.  I will use Markdown for *everything*.  I even use a close relation of Markdown in my scholarly pursuits.\n\n## The Packages: *tidyverse* and *esquisse*\n\nWe will rely on five.  The *tidyverse* is Hadley Wickham's collection of packages.  It represents a different philosophy for the construction of exploratory data analysis with literate programming -- code that you can read.  We will rely on the `%>%` piping operators of the *magrittr* package that pipes something to a subsequent command as a core function of the tidyverse.  \n\nFor everything that we want in a summary, there is the *skimr* function *skim*.  For cross-tabulation the easy way, there is *janitor*.  The other two are developmental pieces of software that have yet to deploy into the regular package system of R.  *esquisse* and parts of *that's so random* blog's package for implementing ggmosaic.\n\n```\npkgTest <- function(x)\n  {\n    if (!require(x,character.only = TRUE))\n    {\n      install.packages(x,dep=TRUE, type=\"binary\")\n        if(!require(x,character.only = TRUE)) stop(\"Package not found\")\n    }\n}\npkgTest(\"tidyverse\")\npkgTest(\"magrittr\")\npkgTest(\"skimr\")\npkgTest(\"janitor\")\npkgTest(\"devtools\")\ndevtools::install_github(\"EdwinTH/thatssorandom\")\npkgTest(\"dreamRs/esquisse\")\n```\n\n## Loading the Data\n\nFirst, the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nBond.Funds <- read.csv(\"https://github.com/robertwwalker/DADMStuff/raw/master/BondFunds.csv\")\n```\n:::\n\n\nWhat does it measure?  Various measures for a collection of bond funds.\n\n1. Type: **Intermediate Government** or **Short-Term Corporate** \n2. Fees: **Yes** or **No**\n3. Risk:  **Above Average**, **Average**, or **Below Average**\n4. Assets: Assets under management (in $ Millions).\n5. Return 2009: The annual returns in 2009.\n6. 3-Year-Return: The average annual return over three years.\n7. 5-Year-Return: The average annual return over five years.\n\n## A first go\n\nTo get a sense of the data, I will load the *skim* function and put it to work.  In *R*, we will use the `library` command to load *functions* into the *namespace* -- the set of recognizable commands.  *R* needs to know how a function is defined to use it.  The function *skim* appears in the *skimr* library.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(skimr)\nskim(Bond.Funds)\n```\n\n::: {.cell-output-display}\nTable: Data summary\n\n|                         |           |\n|:------------------------|:----------|\n|Name                     |Bond.Funds |\n|Number of rows           |184        |\n|Number of columns        |9          |\n|_______________________  |           |\n|Column type frequency:   |           |\n|character                |4          |\n|numeric                  |5          |\n|________________________ |           |\n|Group variables          |None       |\n\n\n**Variable type: character**\n\n|skim_variable | n_missing| complete_rate| min| max| empty| n_unique| whitespace|\n|:-------------|---------:|-------------:|---:|---:|-----:|--------:|----------:|\n|Fund.Number   |         0|             1|   4|   6|     0|      184|          0|\n|Type          |         0|             1|  20|  23|     0|        2|          0|\n|Fees          |         0|             1|   2|   3|     0|        2|          0|\n|Risk          |         0|             1|   7|  13|     0|        3|          0|\n\n\n**Variable type: numeric**\n\n|skim_variable  | n_missing| complete_rate|   mean|      sd|     p0|    p25|   p50|    p75|     p100|hist  |\n|:--------------|---------:|-------------:|------:|-------:|------:|------:|-----:|------:|--------:|:-----|\n|Assets         |         0|             1| 910.65| 2253.27|  12.40| 113.72| 268.4| 621.95| 18603.50|▇▁▁▁▁ |\n|Expense.Ratio  |         0|             1|   0.71|    0.26|   0.12|   0.53|   0.7|   0.90|     1.94|▂▇▅▁▁ |\n|Return.2009    |         0|             1|   7.16|    6.09|  -8.80|   3.48|   6.4|  10.72|    32.00|▁▇▅▁▁ |\n|X3.Year.Return |         0|             1|   4.66|    2.52| -13.80|   4.05|   5.1|   6.10|     9.40|▁▁▁▅▇ |\n|X5.Year.Return |         0|             1|   3.99|    1.49|  -7.30|   3.60|   4.3|   4.90|     6.80|▁▁▁▅▇ |\n:::\n\n```{.r .cell-code}\n# skimr::skim(Bond.Funds)\n```\n:::\n\n\n\n# tidy?\n\nThe beauty of *tidy* is rendering code readable with an organizational focus on data objects.  Let me take the Bond Funds example and use a simple literate example to mirror a pivot table.  Let's pivot two basic statistics, the mean and standard deviation, then the median and interquartile range grouped by Risk.  I should point out that the variable names containing spaces are difficult and have to be enclosed in quotes.  Better naming at the outset would help.  With simple names, we can ignore the quoting.\n\n## Numerical Summary\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nBond.Funds %>% \n  group_by(Risk) %>% \n  summarise(Avg.Return = mean(Return.2009), \n            SD.Return=sd(Return.2009),\n            median.Return=median(Return.2009),\n            IQR.Return=IQR(Return.2009))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 5\n  Risk          Avg.Return SD.Return median.Return IQR.Return\n  <chr>              <dbl>     <dbl>         <dbl>      <dbl>\n1 Above average       8.31      9.24           7.9      13.0 \n2 Average             6.87      4.39           6         7.3 \n3 Below average       6.31      2.71           6.1       3.18\n```\n:::\n:::\n\n\nI can also use *skim*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nBond.Funds %>% \n  group_by(Risk,Fees) %>% \n  skim(Return.2009)\n```\n\n::: {.cell-output-display}\nTable: Data summary\n\n|                         |           |\n|:------------------------|:----------|\n|Name                     |Piped data |\n|Number of rows           |184        |\n|Number of columns        |9          |\n|_______________________  |           |\n|Column type frequency:   |           |\n|numeric                  |1          |\n|________________________ |           |\n|Group variables          |Risk, Fees |\n\n\n**Variable type: numeric**\n\n|skim_variable |Risk          |Fees | n_missing| complete_rate| mean|   sd|   p0|  p25|  p50|   p75| p100|hist  |\n|:-------------|:-------------|:----|---------:|-------------:|----:|----:|----:|----:|----:|-----:|----:|:-----|\n|Return.2009   |Above average |No   |         0|             1| 8.25| 8.92| -8.8| 0.70| 9.90| 13.50| 32.0|▃▃▇▂▁ |\n|Return.2009   |Above average |Yes  |         0|             1| 8.42| 9.96| -4.8| 0.98| 6.85| 14.93| 29.7|▇▆▃▃▂ |\n|Return.2009   |Average       |No   |         0|             1| 7.37| 4.51| -1.1| 4.30| 6.50| 11.20| 16.4|▆▆▇▇▃ |\n|Return.2009   |Average       |Yes  |         0|             1| 5.66| 3.93| -0.6| 3.35| 4.80|  8.00| 12.9|▃▇▅▂▅ |\n|Return.2009   |Below average |No   |         0|             1| 6.33| 2.80|  0.2| 4.85| 6.20|  7.58| 13.0|▂▅▇▃▁ |\n|Return.2009   |Below average |Yes  |         0|             1| 6.26| 2.46|  1.5| 5.02| 6.05|  8.22| 10.1|▂▃▇▆▃ |\n:::\n:::\n\n\n\nI want to recreate a categorical pivot table also.  \n\n## Categorical Descriptions Requires Tables [or Graphics]\n\nThere are numerous ways to build tables in R.  Base R has a *table* function that works but it does not naturally work inside data environments; we have to provide them using `$` or `with` environments [or `%$%` in *magrittr*].  This brief description of environments is part of a broader idea of *scoping* in R.\n\n### Easiest: janitor\n\nThe package *janitor* contains a *tabyl* with the ability to add totals and calculate percentages of relevance.  Here are two examples.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(janitor)\nBond.Funds %>% tabyl(Fees,Risk) %>% adorn_totals(c(\"row\",\"col\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Fees Above average Average Below average Total\n    No            37      49            44   130\n   Yes            22      20            12    54\n Total            59      69            56   184\n```\n:::\n\n```{.r .cell-code}\nBond.Funds %>% tabyl(Fees,Risk) %>% adorn_percentages(\"row\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Fees Above average   Average Below average\n   No     0.2846154 0.3769231     0.3384615\n  Yes     0.4074074 0.3703704     0.2222222\n```\n:::\n:::\n\n\n\n### Easier with xtabs and formulae\n\nThis is actually made much easier with a slightly new form of syntax: formulae.  Base R, as you have already learned (or will learn) with *swirl*, uses different and less readable syntax than the tidyverse.  But this is a problem that is quite easy for R in the base commands *table* and *xtabs* [crosstabs].  In the first instance, we merely create a table counting values.  In the second, the data is a named argument for the function *xtabs* that requires a statement of *margins* for the table as a series of names with \"+\".  The order will determine the rows [first] and the columns [second]. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(Bond.Funds$Fees,Bond.Funds$Risk)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     \n      Above average Average Below average\n  No             37      49            44\n  Yes            22      20            12\n```\n:::\n\n```{.r .cell-code}\nxtabs(~Fees+Risk, data=Bond.Funds)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Risk\nFees  Above average Average Below average\n  No             37      49            44\n  Yes            22      20            12\n```\n:::\n:::\n\n\nThese can also be assigned as objects using the `<-`; this saves a local version of the table as something that we can work on.  I will call mine `FR.Tab` for the F(ees)R(isk).Tab(le).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nFR.Tab <- xtabs(~Fees+Risk, data=Bond.Funds)\n```\n:::\n\n\n### Worst: Table\n\nBase R table is great but it requires that we specify an environment.  To grab a variable from inside a data.frame requires `$`, as in\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(Bond.Funds$Fees,Bond.Funds$Risk)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     \n      Above average Average Below average\n  No             37      49            44\n  Yes            22      20            12\n```\n:::\n\n```{.r .cell-code}\nBRTab1 <- table(Bond.Funds$Fees,Bond.Funds$Risk)\n```\n:::\n\n\nWe can accomplish the same with *with*, telling R to evaluate something inside whatever data object is in *with*, for example,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith(Bond.Funds, table(Fees,Risk))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Risk\nFees  Above average Average Below average\n  No             37      49            44\n  Yes            22      20            12\n```\n:::\n\n```{.r .cell-code}\nWBF1 <- with(Bond.Funds, table(Fees,Risk))\n```\n:::\n\n\n## Conditional Frequency\n\nIf we think about conditional probability as measured in proportions of the table, we can ask R to calculate them.  The command is *prop.table* and the inputs are a table and a *margin* here 1 is rows [conditioning on the first name you entered] and 2 is columns [the second name you entered].  Nothing specified is joint or total.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprop.table(FR.Tab)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Risk\nFees  Above average    Average Below average\n  No     0.20108696 0.26630435    0.23913043\n  Yes    0.11956522 0.10869565    0.06521739\n```\n:::\n\n```{.r .cell-code}\nprop.table(FR.Tab, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Risk\nFees  Above average   Average Below average\n  No      0.2846154 0.3769231     0.3384615\n  Yes     0.4074074 0.3703704     0.2222222\n```\n:::\n\n```{.r .cell-code}\nprop.table(FR.Tab, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Risk\nFees  Above average   Average Below average\n  No      0.6271186 0.7101449     0.7857143\n  Yes     0.3728814 0.2898551     0.2142857\n```\n:::\n\n```{.r .cell-code}\nprop.table(WBF1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Risk\nFees  Above average    Average Below average\n  No     0.20108696 0.26630435    0.23913043\n  Yes    0.11956522 0.10869565    0.06521739\n```\n:::\n\n```{.r .cell-code}\nprop.table(WBF1, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Risk\nFees  Above average   Average Below average\n  No      0.2846154 0.3769231     0.3384615\n  Yes     0.4074074 0.3703704     0.2222222\n```\n:::\n\n```{.r .cell-code}\nprop.table(WBF1, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Risk\nFees  Above average   Average Below average\n  No      0.6271186 0.7101449     0.7857143\n  Yes     0.3728814 0.2898551     0.2142857\n```\n:::\n:::\n\n\n\n## Pivot Plots [Mosaic]\n\nBase R Graphics contain a mosaic with the same formula as the cross-tabulation above.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmosaicplot(~Risk+Fees, data=Bond.Funds)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/MP1-1.png){width=672}\n:::\n:::\n\n\nI recently came across a nice plotter for tabular data on *github*.  You can search for it as *thatssorandom*.  We installed it above.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/pMos-1.png){width=672}\n:::\n:::\n\n\nNotice it handles an implicit plotting of the set of conditional probabilities along the relevant margin.  It is plotting $Pr(Fees|Risk)$ as breaks along the *y-axis* defined by frequency/empirical probability.  This would be the equivalent of taking the *column marginal* of the table of Fees and Risk that we saw before.  Now it has a graphical representation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprop.table(FR.Tab, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Risk\nFees  Above average   Average Below average\n  No      0.6271186 0.7101449     0.7857143\n  Yes     0.3728814 0.2898551     0.2142857\n```\n:::\n:::\n\n\n## For Berkeley Admissions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"UCBAdmissions\")\nUCB <- DescTools::Untable(UCBAdmissions)\nUCB$Gender <- as.character(UCB$Gender)\nUCB$Gender[UCB$Gender==\"Male\"] <- \"M\"\nUCB$Gender[UCB$Gender==\"Female\"] <- \"F\"\nUCB$DeptMF <- paste(UCB$Dept,UCB$Gender, sep=\":\")\nUCB <- UCB %>% select(Admit,DeptMF)\np1 <- ggmm(UCB, x=DeptMF, y=Admit, add_text = \"n\")\np1 + labs(x=\"Dept:M/F\", y=\"Admitted\") + theme(axis.text=element_text(size=10))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n\n## Barplots\n\nBasic things like barplots can be accomplished in many ways.  Using the *R4DS* approach, we have\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = Bond.Funds) + \n  stat_count(mapping = aes(x = Risk))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/GGBar-1.png){width=672}\n:::\n:::\n\n\nPlaced into densities.  This is really only helpful with another dimension because the X is categorical so all bars will be height 1.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = Bond.Funds, aes(x = Risk, fill=Fees)) + geom_bar(position=\"fill\") + theme_minimal()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/GGBar2-1.png){width=672}\n:::\n:::\n\n\nOr in Base R\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(1,2))\nbarplot(table(Bond.Funds$Risk))\nbarplot(table(Bond.Funds$Fees,Bond.Funds$Risk))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/BRBar-1.png){width=672}\n:::\n:::\n\n\nA legend would help.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(1,2))\nbarplot(table(Bond.Funds$Fees,Bond.Funds$Risk), legend=TRUE)\nbarplot(table(Bond.Funds$Fees,Bond.Funds$Risk), legend=TRUE, args.legend=list(bty=\"n\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/BRBar2-1.png){width=672}\n:::\n:::\n\n\n## Simple Visualization: *esquisse()*\n\nThere is a wonderful tool for quickly succeeding with one of the most elegant and frustrating parts of R -- *ggplot2*.  Hadley Wickham's *Grammar of Graphics* is brilliant when understood but is hard to comprehend initially and the programming structure of the package *makes* it hard for learners.  Fortunately, a package called *esquisse* is available to make *ggplot2* drag and drop to harness much of the power in an easy fashion.  With code in the output, it also facilitates learning how to manipulate the code of *ggplot2*.\n\n*esquisse* is quite powerful; we can explore this at length.  Here is a simple graphic that I created with x and fills.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nplt1 <- ggplot(data = Bond.Funds) +\n  aes(x = Type, fill = Fees) +\n  geom_bar() +\n  theme_minimal()\nplt1\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/GGP1-1.png){width=672}\n:::\n:::\n\n\nIf you notice, *esquisse* directly outputs graphics to powerpoint.  This feature is quite useful.",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}